/*
  ==============================================================================

    This file was auto-generated by the Jucer!

    It contains the basic startup code for a Juce application.

 Permission is hereby granted, free of charge, to any person or organization
 obtaining a copy of the software and accompanying documentation covered by
 this license (the "Software") to use, reproduce, display, distribute,
 execute, and transmit the Software, and to prepare derivative works of the
 Software, and to permit third-parties to whom the Software is furnished to
 do so.
 
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 DEALINGS IN THE SOFTWARE.
  
 
  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"
#include "PD_characteristics.h"
#include <math.h>
#include "OwnedCFRef.h"
#include "PDSubprocess.h"
#include <mach/mach_init.h>
#include <mach/thread_policy.h>
#include <mach/thread_act.h>
#include <mach/mach_time.h>
#include <CoreAudio/HostTime.h>


namespace
{
    float scaleFloat(float in, float minVal, float maxVal, PDMessageInfo::Taper taper)
    {
        switch(taper)
        {
            case PDMessageInfo::kLinearTaper:
                return (in * (maxVal - minVal)) + minVal;
                break;
            case PDMessageInfo::kLogTaper:
            {
                double logmin = log(minVal)/log(2);
                double logmax = log(maxVal)/log(2);
                return pow(2, (in * (logmax - logmin)) + logmin);
            }
                break;
        }
        return 0;
    }   
}

//==============================================================================
JucePdAudioProcessor::JucePdAudioProcessor() : fReceivedBuffer(true), 
                                                fOutBuffSize(0),
                                                fBufferSkip(0),
                                                fNotifyThread(0)
{
    CFBundleRef thisBundle = CFBundleGetBundleWithIdentifier(CFSTR(QUOTEME(JucePlugin_CFBundleIdentifier)));
    OwnedCFRef<CFURLRef> exeURL(CFBundleCopyExecutableURL (thisBundle));
    OwnedCFRef<CFStringRef> exePathString(CFURLCopyFileSystemPath(exeURL.get(), kCFURLPOSIXPathStyle));
    char strBuffer[512];
    CFStringGetCString(exePathString.get(), strBuffer, sizeof(strBuffer), kCFStringEncodingMacRoman);
    
    for(int i = strlen(strBuffer); i; --i)
    {
        if(strBuffer[i] == '/')
        {
            strBuffer[i+1] = 0;
            break;
        }
    }
    
    int numParams = sizeof(PDMessages) / sizeof(PDMessageInfo);
    fParams.reset(new float[numParams]);
    for(int i = 0; i < numParams; ++i)
    {
        fParams.get()[i] = PDMessages[i].defaultValue;
    }
    
#if !STANDALONE_VERSION
    fConnection.SetProcessor(this);
    
    int bleh = juce::Random::getSystemRandom().nextInt();
    String pipeName = "JucePDPipe";
    pipeName += bleh;
    bool openedOk = fConnection.createPipe(pipeName);
    if(openedOk)
    {
        printf("pipe succeeded\n");
    }
    
    String filename = strBuffer;
    filename += "PDSubProcess";
    File subProc(filename);
    
    printf("Starting filename %s\n",filename.toUTF8());
    
    subProc.startAsProcess(pipeName);
#endif
}

JucePdAudioProcessor::~JucePdAudioProcessor()
{
#if !STANDALONE_VERSION
    uint32_t opcode = kSubProcQuit;
    MemoryBlock message(&opcode, sizeof(opcode));
    fConnection.sendMessage(message);
    printf("sent message %d\n", opcode);
#endif
}

//==============================================================================
const String JucePdAudioProcessor::getName() const
{
    return JucePlugin_Name;
}

int JucePdAudioProcessor::getNumParameters()
{
    return sizeof(PDMessages) / sizeof(PDMessageInfo);
}

float JucePdAudioProcessor::getParameter (int index)
{
    return fParams.get()[index];
}

void JucePdAudioProcessor::setParameter (int i, float newValue)
{
    (fParams.get())[i] = newValue;
 
    #if !STANDALONE_VERSION
        uint32_t opcode[3] = {kSubProcParam, i, *reinterpret_cast<uint32_t*> (&newValue)};
        MemoryBlock message(&opcode, sizeof(opcode));
        fConnection.sendMessage(message);
    #else
        fSubproc.setParam( i, newValue);
    #endif
    // okay, update all superlisteners
    for(vector<AudioProcessorListener*>::iterator it = fSuperListeners.begin(); it != fSuperListeners.end(); ++it)
    {
        (*it)->audioProcessorParameterChanged(this, i, newValue);
    }
}

const String JucePdAudioProcessor::getParameterName (int i)
{
    return PDMessages[i].name;
}

const String JucePdAudioProcessor::getParameterText (int i)
{
    return String(scaleFloat(getParameter(i), PDMessages[i].minValue, PDMessages[i].maxValue, PDMessages[i].taper));
}

const String JucePdAudioProcessor::getInputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

const String JucePdAudioProcessor::getOutputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

bool JucePdAudioProcessor::isInputChannelStereoPair (int index) const
{
    return true;
}

bool JucePdAudioProcessor::isOutputChannelStereoPair (int index) const
{
    return true;
}

bool JucePdAudioProcessor::acceptsMidi() const
{
#if JucePlugin_WantsMidiInput
    return true;
#else
    return false;
#endif
}

bool JucePdAudioProcessor::producesMidi() const
{
#if JucePlugin_ProducesMidiOutput
    return true;
#else
    return false;
#endif
}

int JucePdAudioProcessor::getNumPrograms()
{
    return 0;
}

int JucePdAudioProcessor::getCurrentProgram()
{
    return 0;
}

void JucePdAudioProcessor::setCurrentProgram (int index)
{
}

const String JucePdAudioProcessor::getProgramName (int index)
{
    return String::empty;
}

void JucePdAudioProcessor::changeProgramName (int index, const String& newName)
{
}

//==============================================================================
void JucePdAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    fOutBuffSize = samplesPerBlock;
    fOutBuff.reset(new float[fOutBuffSize * getNumOutputChannels()]);
    memset(fOutBuff.get(), 0, sizeof(float) * fOutBuffSize * getNumOutputChannels());
    fReceivedBuffer = true;
    
    for(int i = 0; i < getNumParameters(); ++i)
        setParameterNotifyingHost(i, getParameter(i));
    
    #if !STANDALONE_VERSION
        uint32_t opcode[4] = {kSubProcStartup, getNumInputChannels(), getNumOutputChannels(), sampleRate};
        MemoryBlock message(&opcode, sizeof(opcode));
        fConnection.sendMessage(message);
    #else
        fSubproc.startAudio(getNumInputChannels(), getNumOutputChannels(), sampleRate);
    #endif
}

void JucePdAudioProcessor::addSuperListener(AudioProcessorListener* listener)
{
    fSuperListeners.push_back(listener);

    for(int i = 0; i < getNumParameters(); ++i)
        listener->audioProcessorParameterChanged(this, i, getParameter(i));
}

void JucePdAudioProcessor::removeSuperListener(AudioProcessorListener* listener)
{
    for(vector<AudioProcessorListener*>::iterator it = fSuperListeners.begin(); it != fSuperListeners.end(); ++it)
    {  
        if(*it == listener)
        {
            fSuperListeners.erase(it);
            return;
        }
    }
}

void JucePdAudioProcessor::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
}

double min(double a, double b)
{
    if(a < b)
        return a;
    return b;
}

int set_realtime(int period, int computation) {
    struct thread_time_constraint_policy ttcpolicy;
    int ret;
    boolean_t				fetchDefaults = false;
    mach_msg_type_number_t itemCount = THREAD_TIME_CONSTRAINT_POLICY_COUNT;
    thread_policy_get(mach_thread_self(), THREAD_TIME_CONSTRAINT_POLICY, (integer_t*)&ttcpolicy, &itemCount, &fetchDefaults);
    
    ttcpolicy.period=AudioConvertNanosToHostTime(period); // HZ/160
    ttcpolicy.computation=AudioConvertNanosToHostTime(computation); // HZ/3300;
    ttcpolicy.constraint=AudioConvertNanosToHostTime(100000 + computation); // HZ/2200;
    ttcpolicy.preemptible=1;
    
    if ((ret=thread_policy_set(mach_thread_self(),
                               THREAD_TIME_CONSTRAINT_POLICY, (thread_policy_t)&ttcpolicy,
                               itemCount)) != KERN_SUCCESS) {
        printf("set_realtime failed\n");
        return 0;
    }
    printf("set_realtime worked.\n");
    return 1;
}

void JucePdAudioProcessor::receiveMessage(const MemoryBlock& message)
{
    static bool procSet = false;
    if(not procSet)
    {
        Process::setPriority(Process::RealtimePriority);
        
        // mac-specific
        set_realtime(100000,100000);
        procSet = true;
    }
    
    if(message.getSize() < sizeof(uint32_t))
        return;
    
    uint32_t opcode = reinterpret_cast<uint32_t*>(message.getData())[0];
    
    switch(opcode)
    {
        case kHostFillBuffer:
        {
            #if !STANDALONE_VERSION
            CriticalSection::ScopedLockType l(fIPCBufferLock);
            float* inBuffer = &(reinterpret_cast<float*>(message.getData())[1]);
            if(fBufferSkip)
            {
                printf("I received a skipped buffer!\n");
                fBufferSkip--;
            }
            else
            {
                fReceivedBuffer = true;
                
                memcpy(fOutBuff.get(), inBuffer, sizeof(float)*getNumOutputChannels()*fOutBuffSize);
            }
            #endif
        }
            break;
    }
}

void JucePdAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
    if(buffer.getNumSamples() != fOutBuffSize)
    {
        printf("I'm lost!  got wrong number of samples!\n");
        return;
    }
    
    // copy inputs into memory block.
    MemoryBlock block(sizeof(uint32_t) * 2 + fOutBuffSize * sizeof(float) * getNumInputChannels());
    reinterpret_cast<uint32_t*>(block.getData())[0] = kSubProcProcess;
    reinterpret_cast<uint32_t*>(block.getData())[1] = fOutBuffSize;
    for(int channel = 0; channel < getNumInputChannels(); ++channel)
        memcpy(&(reinterpret_cast<float*>(block.getData())[sizeof(uint32_t) * 2 + channel*sizeof(float)*fOutBuffSize]), buffer.getSampleData(channel), sizeof(float)*fOutBuffSize);
    
    // wait a bit for the next buffer
    #if !STANDALONE_VERSION
    CriticalSection::ScopedLockType l(fIPCBufferLock);
    #endif
    
    for(int i = 0; i < 250; ++i)
    {
        if(fReceivedBuffer)
            break;

        #if !STANDALONE_VERSION
            CriticalSection::ScopedUnlockType u(fIPCBufferLock);
        #endif
        Thread::sleep(1);
    }    
    
    if(not fReceivedBuffer)
    {
        printf("skipping buffer! %d\n", fBufferSkip);
        buffer.clear();
        fBufferSkip++;
    }
    else
    {
        //copy in our buffer to the outputs
        for(int channel = 0; channel < getNumOutputChannels(); ++channel)
            memcpy(buffer.getSampleData(channel), &(fOutBuff.get()[channel*fOutBuffSize]), sizeof(float) * fOutBuffSize);
    }
    
    #if !STANDALONE_VERSION
        // queue up the buffer for next time
        fConnection.sendMessage(block);
        fReceivedBuffer = false;
    #else
        fSubproc.doAudioStep(&reinterpret_cast<float*>(block.getData())[2], fOutBuffSize, fOutBuff.get());
        fReceivedBuffer = true;
    #endif
}

void
PDProcessConnection::messageReceived (const MemoryBlock &message)
{
    fProc->receiveMessage(message);
}

//==============================================================================
bool JucePdAudioProcessor::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* JucePdAudioProcessor::createEditor()
{
    return new JucePdAudioProcessorEditor (this);
}

//==============================================================================
void JucePdAudioProcessor::getStateInformation (MemoryBlock& destData)
{
    // You should use this method to store your parameters in the memory block.
    // You could do that either as raw data, or use the XML or ValueTree classes
    // as intermediaries to make it easy to save and load complex data.
}

void JucePdAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    // You should use this method to restore your parameters from this memory block,
    // whose contents will have been created by the getStateInformation() call.
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new JucePdAudioProcessor();
}
